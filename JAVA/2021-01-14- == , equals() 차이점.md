- Java에서 int와 boolean과 같은 일반적인 데이터 타입의 비교는 ==이라는 연산자를 사용하여 비교
- 하지만 String처럼 Class의 값을 비교할때는 ==이 아닌 equals()라는 메소드를 사용하여 비교


# String 변수 생성시 주소할당
* String 변수를 생성할때는 두가지 방법이 존재

1. 리터럴을 이용한 방식
2. new 연산자를 이용한 방식

1번의 경우 string constant pool 영역 (상수 영역)에 존재하게 됨 2번을 통해 생성할 경우 인스턴스를 생성하므로 Heap영역에 존재하게 됨

https://blog.kakaocdn.net/dn/cAbQYM/btrm3PpaEN2/AuIXpphooR5Q2KuPDYf5JK/img.png![image](https://user-images.githubusercontent.com/48741014/149512988-543b6cbc-7b3f-42b8-b78a-c56f94fa04e0.png)


* 주소값 비교(==)와 값 비교(equals)
- ==연산자와 equals()메소드의 가장 큰 차이점은 == 연산자는 비교하고자하는 두개의 대상의 주소값을 비교하는데 반해 String클래스의 equals 메소드는 비교하고자 하는 두개의 대상의 값(value) 자체를 비교하는 것
- 기본 타입의 int형,char 형등은 call by value형태로 기본적으로 대상에 주소값을 가지지 않는 형태로 사용된다. 하지만 String은 일반적인 타입이 아니라 클래스이다.
- 클래스는 기본적으로 call By Reference형태로 생성시 주소값이 부여된다. 그렇기 떄문에 String타입을 선언했을때는 같은 값을 부여하더라도 서로간의 주소값이 다르기때문에 비교시 false가 뜨게된다.

* 추가로 object 클래스는 모든 클래스의 최상위 클래스이고 object 클래스의 메서드인 equals()는 다른 클래스에서 재정의가 가능하다.
* eqauls 역시 재정의 없이 클래스만 비교한다면 주소값(물리적 값)을 비교하고 재정의를 통해 생성 객체 클래스의 멤버변수를 return 해주면 논리적 값을 비교하므로 물리적 값이 달라도 true를 반환한다.
